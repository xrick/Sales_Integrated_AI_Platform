<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MGFD ç­†è¨˜å‹é›»è…¦è³¼ç‰©åŠ©æ‰‹</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 800px;
            height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .header p {
            opacity: 0.9;
            font-size: 14px;
        }

        .chat-container {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f8f9fa;
        }

        .message {
            margin-bottom: 15px;
            display: flex;
            align-items: flex-start;
        }

        .message.user {
            justify-content: flex-end;
        }

        .message.assistant {
            justify-content: flex-start;
        }

        .message-content {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            word-wrap: break-word;
        }

        .message.user .message-content {
            background: #667eea;
            color: white;
            border-bottom-right-radius: 4px;
        }

        .message.assistant .message-content {
            background: white;
            color: #333;
            border: 1px solid #e1e5e9;
            border-bottom-left-radius: 4px;
        }

        .avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            margin: 0 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
        }

        .avatar.user {
            background: #667eea;
            color: white;
        }

        .avatar.assistant {
            background: #28a745;
            color: white;
        }

        .input-container {
            padding: 20px;
            background: white;
            border-top: 1px solid #e1e5e9;
        }

        .input-group {
            display: flex;
            gap: 10px;
        }

        .message-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e1e5e9;
            border-radius: 25px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.3s;
        }

        .message-input:focus {
            border-color: #667eea;
        }

        .send-button {
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.3s;
        }

        .send-button:hover {
            background: #5a6fd8;
        }

        .send-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .session-info {
            background: #e3f2fd;
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 12px;
            color: #1976d2;
        }

        .recommendations {
            background: #f0f8ff;
            border: 1px solid #b3d9ff;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .recommendation-item {
            background: white;
            border: 1px solid #e1e5e9;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
        }

        .recommendation-item:last-child {
            margin-bottom: 0;
        }

        .product-name {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .product-details {
            font-size: 12px;
            color: #666;
            line-height: 1.4;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .stats {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 12px;
            color: #666;
        }

        /* Funnel Question æ¨£å¼ */
        .funnel-container {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
            margin: 10px 0;
        }

        .funnel-container h3 {
            color: #495057;
            margin-bottom: 15px;
            text-align: center;
        }

        .funnel-question {
            font-size: 16px;
            font-weight: 500;
            color: #333;
            margin-bottom: 15px;
            text-align: center;
        }

        .funnel-message {
            color: #6c757d;
            font-size: 14px;
            text-align: center;
            margin-bottom: 20px;
        }

        .funnel-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .funnel-option-btn {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .funnel-option-btn:hover {
            border-color: #667eea;
            background: #f8f9ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.1);
        }

        .funnel-option-btn:active {
            transform: translateY(0);
        }

        .option-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .option-icon {
            font-size: 18px;
            margin-right: 10px;
        }

        .option-title {
            font-weight: 600;
            color: #333;
            font-size: 16px;
        }

        .option-description {
            color: #6c757d;
            font-size: 14px;
            line-height: 1.4;
        }

        /* Elicitation æ¨£å¼ */
        .elicitation-container {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }

        .suggestions {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .suggestion-chip {
            background: #667eea;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            cursor: pointer;
        }

        .suggestion-chip:hover {
            background: #5a6fd8;
        }

        /* Clarification æ¨£å¼ */
        .clarification {
            background: #e3f2fd;
            border: 1px solid #b3d9ff;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }

        /* Funnel Complete æ¨£å¼ */
        .funnel-complete {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            padding: 20px;
            margin: 10px 0;
        }

        .funnel-complete h3 {
            color: #155724;
            text-align: center;
            margin-bottom: 15px;
        }

        .complete-message {
            text-align: center;
            color: #155724;
            font-weight: 500;
            margin-bottom: 20px;
        }

        .flow-info {
            background: white;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .flow-info h4 {
            color: #333;
            margin-bottom: 10px;
        }

        .flow-info p {
            margin-bottom: 8px;
            color: #666;
        }

        .loading-indicator {
            text-align: center;
            color: #6c757d;
        }

        .loading-indicator p {
            margin-top: 10px;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¤– MGFD ç­†è¨˜å‹é›»è…¦è³¼ç‰©åŠ©æ‰‹</h1>
            <p>Multi-Guided Funnel Dialogue æ™ºèƒ½å°è©±ç³»çµ±</p>
        </div>

        <div class="chat-container" id="chatContainer">
            <div class="session-info" id="sessionInfo">
                æ­£åœ¨åˆå§‹åŒ–æœƒè©±...
            </div>
            <div class="stats" id="stats">
                ç³»çµ±ç‹€æ…‹: åˆå§‹åŒ–ä¸­...
            </div>
        </div>

        <div class="input-container">
            <div class="input-group">
                <input 
                    type="text" 
                    id="messageInput" 
                    class="message-input" 
                    placeholder="è«‹å‘Šè¨´æˆ‘æ‚¨æƒ³è¦ä»€éº¼æ¨£çš„ç­†é›»..."
                    disabled
                >
                <button id="sendButton" class="send-button" disabled>
                    ç™¼é€
                </button>
            </div>
        </div>
    </div>

    <script>
        class MGFDChat {
            constructor() {
                this.sessionId = null;
                this.isLoading = false;
                this.renderedQuestions = new Set(); // è¿½è¹¤å·²æ¸²æŸ“çš„å•é¡Œ
                this.questionHistory = new Map(); // å•é¡Œæ­·å²è¨˜éŒ„
                this.init();
            }

            async init() {
                try {
                    await this.createSession();
                    await this.loadStats();
                    this.setupEventListeners();
                    this.enableInput();
                } catch (error) {
                    console.error('åˆå§‹åŒ–å¤±æ•—:', error);
                    this.showError('ç³»çµ±åˆå§‹åŒ–å¤±æ•—ï¼Œè«‹åˆ·æ–°é é¢é‡è©¦');
                }
            }

            async createSession() {
                const response = await fetch('/api/mgfd_cursor/session/create', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({})
                });

                if (!response.ok) {
                    throw new Error('å‰µå»ºæœƒè©±å¤±æ•—');
                }

                const data = await response.json();
                this.sessionId = data.session_id;
                
                // ğŸ”„ æ¸…ç†å•é¡Œæ­·å²ï¼ˆæ–°æœƒè©±æ™‚ï¼‰
                this.questionHistory.clear();
                this.renderedQuestions.clear();
                console.log('ğŸ†• New session created, question history cleared');
                
                this.addMessage('assistant', data.message);
                this.updateSessionInfo();
            }

            async loadStats() {
                try {
                    const response = await fetch('/api/mgfd_cursor/stats');
                    if (response.ok) {
                        const data = await response.json();
                        this.updateStats(data.system_stats);
                    }
                } catch (error) {
                    console.error('è¼‰å…¥çµ±è¨ˆä¿¡æ¯å¤±æ•—:', error);
                }
            }

            setupEventListeners() {
                const messageInput = document.getElementById('messageInput');
                const sendButton = document.getElementById('sendButton');

                messageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !this.isLoading) {
                        this.sendMessage();
                    }
                });

                sendButton.addEventListener('click', () => {
                    if (!this.isLoading) {
                        this.sendMessage();
                    }
                });
            }

            enableInput() {
                document.getElementById('messageInput').disabled = false;
                document.getElementById('sendButton').disabled = false;
            }

            async sendMessage() {
                const messageInput = document.getElementById('messageInput');
                const message = messageInput.value.trim();

                if (!message || this.isLoading) return;

                this.isLoading = true;
                this.setLoadingState(true);

                // æ·»åŠ ç”¨æˆ¶æ¶ˆæ¯
                this.addMessage('user', message);
                messageInput.value = '';

                try {
                    const response = await fetch('/api/mgfd_cursor/chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            message: message,
                            session_id: this.sessionId
                        })
                    });

                    if (!response.ok) {
                        throw new Error('ç™¼é€æ¶ˆæ¯å¤±æ•—');
                    }

                    const data = await response.json();
                    
                    console.log('ğŸ”„ Received data from backend:', data);
                    
                    // æ™ºèƒ½è™•ç†å…©ç¨®å›æ‡‰æ ¼å¼
                    let content, fullData;
                    
                    if (data.type && (data.type === 'funnel_question' || data.type === 'funnel_complete' || data.type === 'elicitation' || data.type === 'recommendation' || data.type === 'clarification' || data.type === 'error')) {
                        // ç›´æ¥çš„çµæ§‹åŒ–å›æ‡‰æ ¼å¼
                        content = data;  // å°‡æ•´å€‹ç‰©ä»¶ä½œç‚ºå…§å®¹
                        fullData = data;
                        console.log('ğŸ“‹ Detected structured response format:', data.type);
                    } else if (data.response !== undefined) {
                        // æ¨™æº–çš„åŒ…è£æ ¼å¼ {response: content, ...}
                        content = data.response;
                        fullData = data;
                        console.log('ğŸ“¦ Detected standard response format');
                    } else if (data.success === false && data.error) {
                        // éŒ¯èª¤å›æ‡‰æ ¼å¼
                        content = data.error;
                        fullData = data;
                        console.log('âŒ Detected error response format');
                    } else {
                        // é™ç´šè™•ç†ï¼šå°‡æ•´å€‹å›æ‡‰ä½œç‚ºå…§å®¹è™•ç†
                        content = data;
                        fullData = data;
                        console.log('ğŸ”§ Fallback: treating entire data as structured content');
                    }
                    
                    // æ·»åŠ åŠ©æ‰‹å›æ‡‰
                    this.addMessage('assistant', content, fullData);

                    // æ›´æ–°æœƒè©±ä¿¡æ¯
                    this.updateSessionInfo(fullData);

                } catch (error) {
                    console.error('ç™¼é€æ¶ˆæ¯å¤±æ•—:', error);
                    this.showError('ç™¼é€æ¶ˆæ¯å¤±æ•—ï¼Œè«‹é‡è©¦');
                } finally {
                    this.isLoading = false;
                    this.setLoadingState(false);
                }
            }

            addMessage(role, content, data = null) {
                const chatContainer = document.getElementById('chatContainer');
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${role}`;

                const avatar = document.createElement('div');
                avatar.className = `avatar ${role}`;
                avatar.textContent = role === 'user' ? 'U' : 'A';

                const messageContent = document.createElement('div');
                messageContent.className = 'message-content';

                if (role === 'assistant') {
                    // è™•ç†åŠ©æ‰‹å›æ‡‰ - æ”¯æ´çµæ§‹åŒ–JSONå›æ‡‰
                    this.renderAssistantMessage(messageContent, content, data);
                } else {
                    // ç”¨æˆ¶æ¶ˆæ¯ä¿æŒç°¡å–®æ–‡å­—é¡¯ç¤º
                    messageContent.textContent = content;
                }

                messageDiv.appendChild(avatar);
                messageDiv.appendChild(messageContent);
                chatContainer.appendChild(messageDiv);

                // æ»¾å‹•åˆ°åº•éƒ¨
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }

            renderAssistantMessage(container, content, data = null) {
                console.log('ğŸ”§ renderAssistantMessage called with:', { 
                    contentType: typeof content, 
                    contentValue: content, 
                    dataType: typeof data,
                    dataKeys: data ? Object.keys(data) : null
                });
                
                // è™•ç† null æˆ– undefined çš„å…§å®¹
                if (content === null || content === undefined) {
                    console.error('âŒ Content is null or undefined, using fallback');
                    if (data && typeof data === 'object') {
                        content = data;  // ä½¿ç”¨æ•´å€‹ data å°è±¡ä½œç‚ºå…§å®¹
                        console.log('ğŸ”„ Using data object as content:', data);
                    } else {
                        container.innerHTML = '<p style="color: orange;">âš ï¸ æ”¶åˆ°ç©ºç™½å›æ‡‰</p>';
                        return;
                    }
                }
                
                // å¦‚æœcontentæ˜¯å­—ç¬¦ä¸²ä½†çœ‹èµ·ä¾†åƒJSONï¼Œå˜—è©¦è§£æ
                let parsedContent = content;
                if (typeof content === 'string') {
                    try {
                        // æª¢æŸ¥æ˜¯å¦æ˜¯JSONå­—ç¬¦ä¸²
                        if (content.trim().startsWith('{') && content.trim().endsWith('}')) {
                            parsedContent = JSON.parse(content);
                            console.log('ğŸ“ Parsed JSON content:', parsedContent);
                        }
                    } catch (e) {
                        console.log('ğŸ“ Content is not JSON, treating as plain text:', e.message);
                    }
                }
                
                // å¦‚æœæ˜¯çµæ§‹åŒ–æ•¸æ“šï¼Œè™•ç†ç‰¹æ®Šé¡å‹
                if (typeof parsedContent === 'object' && parsedContent !== null) {
                    console.log('ğŸ¯ Processing structured content:', parsedContent);
                    this.renderStructuredResponse(container, parsedContent);
                } else if (data && data.recommendations) {
                    // å…¼å®¹èˆŠæ ¼å¼ï¼šå¦‚æœæœ‰æ¨è–¦ç”¢å“ï¼Œæ ¼å¼åŒ–é¡¯ç¤º
                    console.log('ğŸ“‹ Processing legacy recommendation format');
                    container.innerHTML = this.formatRecommendations(content, data.recommendations);
                } else {
                    // æ™®é€šæ–‡å­—å›æ‡‰
                    console.log('ğŸ“„ Processing plain text response');
                    container.textContent = content || '(ç©ºç™½å›æ‡‰)';
                }
            }

            renderStructuredResponse(container, response) {
                console.log('ğŸ¯ renderStructuredResponse called with:', response);
                
                const responseType = response.type || 'text';
                
                switch (responseType) {
                    case 'funnel_question':
                        this.renderFunnelQuestion(container, response);
                        break;
                    case 'funnel_complete':
                        this.renderFunnelComplete(container, response);
                        break;
                    case 'elicitation':
                        this.renderElicitation(container, response);
                        break;
                    case 'recommendation':
                        this.renderRecommendation(container, response);
                        break;
                    case 'clarification':
                        this.renderClarification(container, response);
                        break;
                    case 'error':
                        this.renderError(container, response);
                        break;
                    default:
                        // è™•ç†æœªçŸ¥é¡å‹æˆ–ä¸€èˆ¬å›æ‡‰
                        this.renderGeneralResponse(container, response);
                }
            }

            renderFunnelQuestion(container, response) {
                console.log('ğŸ”¥ Rendering funnel question:', response);
                
                // å¢å¼·çš„æ ¼å¼é©—è­‰å’ŒéŒ¯èª¤è™•ç†
                if (!response) {
                    console.error('âŒ Response is null or undefined');
                    container.innerHTML = '<p style="color: red;">å›æ‡‰æ•¸æ“šç‚ºç©º</p>';
                    return;
                }
                
                const { question, session_id, message } = response;
                
                // è©³ç´°çš„å­—æ®µé©—è­‰
                if (!question) {
                    console.error('âŒ Missing question field in response:', response);
                    container.innerHTML = '<p style="color: red;">ç¼ºå°‘å•é¡Œæ•¸æ“š</p>';
                    return;
                }
                
                if (!question.question_text) {
                    console.error('âŒ Missing question_text in question:', question);
                    container.innerHTML = '<p style="color: red;">ç¼ºå°‘å•é¡Œæ–‡å­—</p>';
                    return;
                }
                
                if (!question.options || !Array.isArray(question.options) || question.options.length === 0) {
                    console.error('âŒ Invalid options in question:', question.options);
                    container.innerHTML = '<p style="color: red;">ç¼ºå°‘æœ‰æ•ˆçš„é¸é …</p>';
                    return;
                }
                
                // é©—è­‰é¸é …æ ¼å¼
                for (let i = 0; i < question.options.length; i++) {
                    const option = question.options[i];
                    if (!option.option_id || !option.label || !option.description) {
                        console.error(`âŒ Invalid option at index ${i}:`, option);
                        container.innerHTML = `<p style="color: red;">é¸é … ${i + 1} æ ¼å¼éŒ¯èª¤</p>`;
                        return;
                    }
                }
                
                // ğŸ”„ æ–°å¢ï¼šå»é‡é‚è¼¯æª¢æŸ¥  
                const questionKey = this.generateQuestionKey(question, session_id);
                const currentTime = Date.now();
                
                // æª¢æŸ¥æ˜¯å¦æ˜¯é‡è¤‡çš„å•é¡Œï¼ˆ5åˆ†é˜å…§çš„ç›¸åŒå•é¡Œè¦–ç‚ºé‡è¤‡ï¼‰
                if (this.questionHistory.has(questionKey)) {
                    const lastTime = this.questionHistory.get(questionKey);
                    const timeDiff = currentTime - lastTime;
                    const DUPLICATE_THRESHOLD = 5 * 60 * 1000; // 5åˆ†é˜
                    
                    if (timeDiff < DUPLICATE_THRESHOLD) {
                        console.warn('ğŸš« Duplicate funnel question detected, skipping render:', {
                            questionKey,
                            timeDiff: `${Math.round(timeDiff/1000)}s`,
                            threshold: `${DUPLICATE_THRESHOLD/1000}s`
                        });
                        
                        container.innerHTML = `
                            <div class="funnel-container" style="opacity: 0.7; border: 2px dashed #ffc107;">
                                <h3>âš ï¸ é‡è¤‡å•é¡Œåµæ¸¬</h3>
                                <p class="funnel-message">æ­¤å•é¡Œåœ¨ ${Math.round(timeDiff/1000)} ç§’å‰å·²é¡¯ç¤ºéï¼Œå·²è‡ªå‹•ç•¥éé‡è¤‡æ¸²æŸ“ã€‚</p>
                                <p style="font-size: 12px; color: #6c757d;">å¦‚æœé€™æ˜¯éŒ¯èª¤ï¼Œè«‹é‡æ–°æ•´ç†é é¢æˆ–è¯çµ¡æŠ€è¡“æ”¯æ´ã€‚</p>
                            </div>
                        `;
                        return;
                    }
                }
                
                // è¨˜éŒ„æ­¤å•é¡Œçš„é¡¯ç¤ºæ™‚é–“
                this.questionHistory.set(questionKey, currentTime);
                
                console.log('âœ… Funnel question validation passed');
                
                let html = `
                    <div class="funnel-container" data-question-key="${questionKey}">
                        <h3>ğŸ¯ éœ€æ±‚é¡å‹é¸æ“‡</h3>
                        <p class="funnel-question">${question.question_text}</p>
                        ${message ? `<p class="funnel-message">${message}</p>` : ''}
                        
                        <div class="funnel-options">
                `;
                
                question.options.forEach((option, index) => {
                    html += `
                        <button class="funnel-option-btn" 
                                data-option-id="${option.option_id}" 
                                data-session-id="${session_id}"
                                onclick="mgfdChat.handleFunnelOptionClick('${option.option_id}', '${session_id}')">
                            <div class="option-header">
                                <span class="option-icon">${option.label.split(' ')[0] || 'ğŸ“‹'}</span>
                                <span class="option-title">${option.label.split(' ').slice(1).join(' ') || option.label}</span>
                            </div>
                            <div class="option-description">${option.description}</div>
                        </button>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
                
                container.innerHTML = html;
            }
            
            // ğŸ†• æ–°å¢ï¼šç”Ÿæˆå•é¡Œå”¯ä¸€éµçš„æ–¹æ³•
            generateQuestionKey(question, sessionId = '') {
                // åŸºæ–¼å•é¡Œæ–‡å­—ã€é¸é …å’Œæœƒè©±IDç”Ÿæˆå”¯ä¸€éµ
                const questionText = question.question_text || '';
                const optionsText = question.options ? 
                    question.options.map(opt => `${opt.option_id}-${opt.label}`).join('|') : '';
                
                // åŒ…å«session_idé¿å…ä¸åŒæœƒè©±é–“çš„é‡è¤‡å•é¡Œèª¤åˆ¤
                const key = `${sessionId}::${questionText}::${optionsText}`;
                
                // ä½¿ç”¨ç°¡å–®çš„é›œæ¹Šå‡½æ•¸ç”Ÿæˆè¼ƒçŸ­çš„éµ
                let hash = 0;
                for (let i = 0; i < key.length; i++) {
                    const char = key.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // è½‰æ›ç‚º32ä½æ•´æ•¸
                }
                
                return `fq_${Math.abs(hash).toString(16)}`;
            }

            renderElicitation(container, response) {
                const content = response.content || 'è«‹æä¾›æ›´å¤šè³‡è¨Šä»¥å¹«åŠ©æ‚¨æ‰¾åˆ°åˆé©çš„ç”¢å“ã€‚';
                const suggestions = response.suggestions || [];
                
                let html = `
                    <div class="elicitation-container">
                        <p>${content}</p>
                `;
                
                if (suggestions.length > 0) {
                    html += '<div class="suggestions">';
                    suggestions.forEach(suggestion => {
                        html += `<span class="suggestion-chip">${suggestion}</span>`;
                    });
                    html += '</div>';
                }
                
                html += '</div>';
                container.innerHTML = html;
            }

            renderRecommendation(container, response) {
                const content = response.content || '';
                const recommendations = response.recommendations || [];
                
                container.innerHTML = this.formatRecommendations(content, recommendations);
            }

            renderFunnelComplete(container, response) {
                console.log('âœ… Rendering funnel complete:', response);
                
                const { target_flow, original_query, user_choice, message } = response;
                
                let html = `
                    <div class="funnel-complete">
                        <h3>âœ… éœ€æ±‚åˆ†æå®Œæˆ</h3>
                        <p class="complete-message">${message || 'å·²ç‚ºæ‚¨åˆ†æå®Œæˆï¼Œæ­£åœ¨æº–å‚™çµæœ...'}</p>
                        
                        <div class="flow-info">
                            <h4>ğŸ“‹ åˆ†æçµæœ</h4>
                            <p><strong>åŸå§‹æŸ¥è©¢ï¼š</strong>${original_query || 'æœªçŸ¥'}</p>
                            <p><strong>é¸æ“‡æµç¨‹ï¼š</strong>${target_flow || 'æœªçŸ¥'}</p>
                            ${user_choice ? `<p><strong>é¸æ“‡é¸é …ï¼š</strong>${user_choice.label || user_choice}</p>` : ''}
                        </div>
                        
                        <div class="loading-indicator">
                            <div class="loading"></div>
                            <p>æ­£åœ¨åŸ·è¡Œå°ˆæ¥­åˆ†æ...</p>
                        </div>
                    </div>
                `;
                
                container.innerHTML = html;
                
                // å¦‚æœæœ‰é€²ä¸€æ­¥çš„è™•ç†çµæœï¼Œå¯ä»¥åœ¨é€™è£¡æ·»åŠ 
                if (response.recommendations) {
                    // ç›´æ¥é¡¯ç¤ºæ¨è–¦çµæœ
                    setTimeout(() => {
                        this.renderRecommendation(container, response);
                    }, 1500);
                }
            }

            renderClarification(container, response) {
                const content = response.content || 'éœ€è¦æ‚¨æ¾„æ¸…ä¸€äº›ç´°ç¯€ã€‚';
                container.innerHTML = `<div class="clarification">${content}</div>`;
            }

            renderError(container, response) {
                const error = response.error || response.content || 'ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤';
                container.innerHTML = `<div class="error">âŒ ${error}</div>`;
            }

            renderGeneralResponse(container, response) {
                console.log('ğŸ”§ renderGeneralResponse called with:', response);
                
                // è™•ç†ä¸€èˆ¬çµæ§‹åŒ–å›æ‡‰
                if (response.content) {
                    console.log('ğŸ“„ Using response.content');
                    container.innerHTML = response.content;
                } else if (response.message) {
                    console.log('ğŸ“„ Using response.message');
                    container.innerHTML = response.message;
                } else if (typeof response === 'string') {
                    console.log('ğŸ“„ Response is string, displaying directly');
                    container.textContent = response;
                } else {
                    // å¦‚æœæ²’æœ‰æ˜ç¢ºçš„å…§å®¹å­—æ®µï¼Œå˜—è©¦æä¾›æ›´å‹å–„çš„é¡¯ç¤º
                    console.log('â“ Unknown response format, using fallback display');
                    
                    let displayContent = '';
                    
                    // æª¢æŸ¥æ˜¯å¦æœ‰å¸¸è¦‹çš„å­—æ®µ
                    if (response.type) {
                        displayContent += `<p><strong>é¡å‹:</strong> ${response.type}</p>`;
                    }
                    
                    if (response.error) {
                        displayContent += `<p style="color: red;"><strong>éŒ¯èª¤:</strong> ${response.error}</p>`;
                    }
                    
                    if (response.session_id) {
                        displayContent += `<p><strong>æœƒè©±ID:</strong> ${response.session_id}</p>`;
                    }
                    
                    // å¦‚æœæ²’æœ‰ä»»ä½•æœ‰ç”¨çš„å­—æ®µï¼Œé¡¯ç¤ºJSONï¼ˆä½†æ›´ç¾è§€ï¼‰
                    if (!displayContent) {
                        displayContent = `
                            <div style="background: #f5f5f5; padding: 10px; border-radius: 8px; margin: 10px 0;">
                                <p><strong>âš ï¸ æœªçŸ¥å›æ‡‰æ ¼å¼</strong></p>
                                <details>
                                    <summary>é»æ“ŠæŸ¥çœ‹åŸå§‹æ•¸æ“š (èª¿è©¦ç”¨)</summary>
                                    <pre style="font-size: 12px; overflow-x: auto;">${JSON.stringify(response, null, 2)}</pre>
                                </details>
                            </div>
                        `;
                    }
                    
                    container.innerHTML = displayContent;
                }
            }

            async handleFunnelOptionClick(optionId, sessionId) {
                console.log('ğŸ¯ Funnel option clicked:', { optionId, sessionId });
                
                // ğŸ”„ ç¦ç”¨æ‰€æœ‰é¸é …æŒ‰éˆ•é˜²æ­¢é‡è¤‡é»æ“Š
                const optionButtons = document.querySelectorAll('.funnel-option-btn');
                optionButtons.forEach(btn => {
                    btn.disabled = true;
                    btn.style.opacity = '0.6';
                    btn.style.cursor = 'not-allowed';
                });
                
                // æ¨™ç¤ºå·²é¸æ“‡çš„é¸é …
                const selectedButton = document.querySelector(`[data-option-id="${optionId}"]`);
                if (selectedButton) {
                    selectedButton.style.backgroundColor = '#667eea';
                    selectedButton.style.color = 'white';
                    selectedButton.style.border = '2px solid #667eea';
                }
                
                try {
                    // ç™¼é€é¸æ“‡åˆ°å¾Œç«¯
                    const response = await fetch('/api/mgfd_cursor/chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            message: `é¸æ“‡é¸é …: ${optionId}`,
                            session_id: sessionId
                        })
                    });

                    if (!response.ok) {
                        throw new Error('è™•ç†é¸æ“‡å¤±æ•—');
                    }

                    const data = await response.json();
                    
                    // ğŸ—ºï¸ æ¸…ç†ç›¸é—œçš„å•é¡Œæ­·å²ï¼ˆé¿å…é‡è¤‡å•é¡Œï¼‰
                    this.clearRelatedQuestionHistory(optionId, sessionId);
                    
                    // æ·»åŠ æ–°çš„å›æ‡‰
                    this.addMessage('assistant', data.response, data);
                    this.updateSessionInfo(data);

                } catch (error) {
                    console.error('è™•ç†funnelé¸æ“‡å¤±æ•—:', error);
                    this.showError('è™•ç†é¸æ“‡å¤±æ•—ï¼Œè«‹é‡è©¦');
                    
                    // ğŸ”„ ç™¼ç”ŸéŒ¯èª¤æ™‚é‡æ–°å•Ÿç”¨é¸é …æŒ‰éˆ•
                    const optionButtons = document.querySelectorAll('.funnel-option-btn');
                    optionButtons.forEach(btn => {
                        btn.disabled = false;
                        btn.style.opacity = '1';
                        btn.style.cursor = 'pointer';
                    });
                }
            }
            
            // ğŸ—ºï¸ æ–°å¢ï¼šæ¸…ç†ç›¸é—œå•é¡Œæ­·å²çš„æ–¹æ³•
            clearRelatedQuestionHistory(selectedOptionId, currentSessionId = '') {
                console.log('ğŸ§¹ Clearing related question history for option:', selectedOptionId, 'session:', currentSessionId);
                
                // æ¸…ç†ç­–ç•¥ï¼š
                // 1. æ¸…ç†è¶…é10åˆ†é˜çš„èˆŠå•é¡Œæ­·å²
                // 2. æ¸…ç†ç•¶å‰æœƒè©±ä¸­å¯èƒ½å°è‡´å¾ªç’°çš„ç›¸é—œå•é¡Œ
                const keysToDelete = [];
                const currentTime = Date.now();
                const MAX_AGE = 10 * 60 * 1000; // 10åˆ†é˜
                
                for (const [key, timestamp] of this.questionHistory.entries()) {
                    // æ¸…ç†è¶…é10åˆ†é˜çš„èˆŠå•é¡Œæ­·å²
                    const age = currentTime - timestamp;
                    if (age > MAX_AGE) {
                        keysToDelete.push(key);
                        console.log('ğŸ•’ Marking old question for deletion:', key, `(${Math.round(age/1000)}s old)`);
                        continue;
                    }
                    
                    // æ¸…ç†ç•¶å‰æœƒè©±ä¸­5åˆ†é˜å…§çš„ç›¸é—œå•é¡Œï¼ˆé˜²æ­¢ç«‹å³é‡è¤‡ï¼‰
                    if (currentSessionId && age < 5 * 60 * 1000) {
                        // å¦‚æœå•é¡ŒåŒ…å«ç•¶å‰æœƒè©±IDä¸”æ™‚é–“è¼ƒè¿‘ï¼Œè€ƒæ…®æ¸…ç†
                        const sessionPrefix = `fq_`;
                        if (key.startsWith(sessionPrefix)) {
                            // é€™æ˜¯ä¸€å€‹funnel questionï¼Œå¦‚æœç”¨æˆ¶å·²ç¶“é¸æ“‡äº†é¸é …ï¼Œæ¸…ç†ç›¸é—œçš„å•é¡Œ
                            keysToDelete.push(key);
                            console.log('ğŸ”„ Marking recent related question for deletion:', key, `(${Math.round(age/1000)}s ago)`);
                        }
                    }
                }
                
                // åˆªé™¤æ¨™è¨˜çš„å•é¡Œæ­·å²
                keysToDelete.forEach(key => {
                    this.questionHistory.delete(key);
                    console.log('ğŸ—‘ï¸ Cleaned question:', key);
                });
                
                console.log('âœ… Question history cleanup complete:', {
                    remainingEntries: this.questionHistory.size,
                    deletedEntries: keysToDelete.length,
                    selectedOption: selectedOptionId,
                    sessionId: currentSessionId
                });
            }

            formatRecommendations(content, recommendations) {
                let html = `<div>${content}</div>`;
                
                if (recommendations && recommendations.length > 0) {
                    html += '<div class="recommendations">';
                    recommendations.forEach(product => {
                        html += `
                            <div class="recommendation-item">
                                <div class="product-name">${product.name}</div>
                                <div class="product-details">
                                    å“ç‰Œ: ${product.brand.toUpperCase()}<br>
                                    è™•ç†å™¨: ${product.cpu}<br>
                                    é¡¯ç¤ºå¡: ${product.gpu}<br>
                                    è¨˜æ†¶é«”: ${product.ram}<br>
                                    é‡é‡: ${product.weight}<br>
                                    æè¿°: ${product.description}
                                </div>
                            </div>
                        `;
                    });
                    html += '</div>';
                }

                return html;
            }

            updateSessionInfo(data = null) {
                const sessionInfo = document.getElementById('sessionInfo');
                if (data) {
                    sessionInfo.innerHTML = `
                        æœƒè©±ID: ${this.sessionId}<br>
                        ç•¶å‰éšæ®µ: ${data.current_stage}<br>
                        å·²å¡«å¯«æ§½ä½: ${Object.keys(data.filled_slots).length}
                    `;
                } else {
                    sessionInfo.innerHTML = `æœƒè©±ID: ${this.sessionId}`;
                }
            }

            updateStats(stats) {
                const statsDiv = document.getElementById('stats');
                statsDiv.innerHTML = `
                    æ´»èºæœƒè©±: ${stats.active_sessions} | 
                    ç”¢å“æ•¸é‡: ${stats.total_products} | 
                    æ§½ä½æ¶æ§‹: ${stats.slot_schema_count}
                `;
            }

            setLoadingState(loading) {
                const sendButton = document.getElementById('sendButton');
                const messageInput = document.getElementById('messageInput');

                if (loading) {
                    sendButton.innerHTML = '<div class="loading"></div>';
                    sendButton.disabled = true;
                    messageInput.disabled = true;
                } else {
                    sendButton.innerHTML = 'ç™¼é€';
                    sendButton.disabled = false;
                    messageInput.disabled = false;
                }
            }

            showError(message) {
                const chatContainer = document.getElementById('chatContainer');
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error';
                errorDiv.textContent = message;
                chatContainer.appendChild(errorDiv);
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }
        }

        // åˆå§‹åŒ–èŠå¤©
        let mgfdChat;
        document.addEventListener('DOMContentLoaded', () => {
            mgfdChat = new MGFDChat();
        });
    </script>
</body>
</html>



