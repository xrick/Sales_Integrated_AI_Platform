# Simulate the actual backend search process           │
│   import sys                                             │
│   sys.path.append('.')                                   │
│   from pymilvus import connections, Collection           │
│   from sentence_transformers import                      │
│   SentenceTransformer                                    │
│   import duckdb                                          │
│                                                          │
│   # Connect to systems                                   │
│   connections.connect('default', host='localhost',       │
│   port='19530')                                          │
│   collection =                                           │
│   Collection('semantic_nb_spec_250921_utf8')             │
│   collection.load()                                      │
│   model = SentenceTransformer('sentence-transformers/p   │
│   araphrase-multilingual-MiniLM-L12-v2')                 │
│                                                          │
│   # Test the exact user query                            │
│   user_query = 'Does APX819 support dual-channel RAM     │
│   configuration?'                                        │
│   print(f'User Query: \"{user_query}\"')                 │
│                                                          │
│   # Step 1: Generate embedding                           │
│   query_embedding = model.encode([user_query])           │
│                                                          │
│   # Step 2: Search Milvus (simulate top 3 like           │
│   backend)                                               │
│   search_params = {'metric_type': 'L2', 'params':        │
│   {'nprobe': 16}}                                        │
│   results = collection.search(                           │
│       data=query_embedding,                              │
│       anns_field='embedding',                            │
│       param=search_params,                               │
│       limit=3,  # Backend typically gets top 3           │
│       output_fields=['product_id', 'chunk_type',         │
│   'content']                                             │
│   )                                                      │
│                                                          │
│   print('\\nStep 1: Milvus semantic search results       │
│   (top 3):')                                             │
│   product_ids = []                                       │
│   for i, result in enumerate(results[0]):                │
│       product_id = result.entity.get('product_id')       │
│       distance = result.distance                         │
│       product_ids.append(product_id)                     │
│       print(f'{i+1}. Product ID: {product_id} |          │
│   Distance: {distance:.4f}')                             │
│       print(f'   Content:                                │
│   {result.entity.get(\"content\")}')                     │
│                                                          │
│   print(f'\\nExtracted Product IDs for database          │
│   lookup: {product_ids}')                                │
│                                                          │
│   # Step 3: Query DuckDB for complete specifications     │
│   (simulate backend)                                     │
│   print('\\nStep 2: DuckDB specification lookup:')       │
│   con = duckdb.connect('../db/all_nbinfo_v3.db',         │
│   read_only=True)                                        │
│                                                          │
│   for pid in product_ids:                                │
│       print(f'\\n--- Product ID {pid} ---')              │
│       # Get all products with this modeltype             │
│       query = '''                                        │
│           SELECT modeltype, modelname, version,          │
│   memory, wireless                                       │
│           FROM nbtypes                                   │
│           WHERE modeltype = ?                            │
│           ORDER BY modelname                             │
│       '''                                                │
│       results = con.execute(query, [pid]).fetchall()     │
│                                                          │
│       if results:                                        │
│           for row in results:                            │
│               modeltype, modelname, version, memory,     │
│   wireless = row                                         │
│               print(f'  {modelname} ({version})')        │
│               # Check for dual-channel in memory spec    │
│               if memory and 'dual' in memory.lower():    │
│                   print(f'    Memory:                    │
│   {memory[:100]}... ✅ DUAL-CHANNEL FOUND')               │
│               else:                                      │
│                   print(f'    Memory: {memory[:100] if   │
│    memory else \"N/A\"}...')                             │
│       else:                                              │
│           print(f'  No products found for modeltype      │
│   {pid}')                                                │
│                                                          │
│   con.close()                                            │
│                                                          │
│   print()                                                │
│   print('=== ROOT CAUSE CONFIRMED ===')                  │
│   print('❌ PROBLEM: Semantic search ranking is           │
│   incorrect')                                            │
│   print('❌ APX819 query returns modeltype 839, 829,      │
│   958 instead of 819')                                   │
│   print('❌ The issue is NOT missing data - it\\'s        │
│   search algorithm ranking')                             │
│   print('⚠️  99.01% similarity between APX819 and        │
│   APX839 embeddings')                                    │
│   print('⚠️  Generic Chinese template content reduces    │
│   specificity')                                          │
│                                                          │
│   connections.disconnect('default')