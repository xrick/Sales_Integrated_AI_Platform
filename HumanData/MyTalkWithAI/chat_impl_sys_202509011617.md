[3 tools called]

## 🚀 MGFDKernel 與 UserInputHandler 進階設計規劃

基於你的反饋與我對 `mgfd_ai.js` 和 `default_slots.json` 的分析，我現在進行更深入的設計規劃：

### 一、MGFDKernel 進階設計（系統大腦）

#### **1.1 核心架構與職責**
```python
class MGFDKernel:
    """
    MGFD系統核心控制器 - 對外唯一介面
    職責：協調五大模組，管理對話流程，處理前端請求
    """
    
    def __init__(self, redis_client=None):
        # 初始化五大模組
        self.user_input_handler = UserInputHandler()
        self.prompt_manager = PromptManagementHandler() 
        self.knowledge_manager = KnowledgeManagementHandler()
        self.response_generator = ResponseGenHandler()
        self.state_manager = StateManagementHandler(redis_client)
        
        # 系統配置
        self.config = self._load_config()
        self.slot_schema = self._load_slot_schema()
```

#### **1.2 公開介面設計（對齊 mgfd_ai.js）**
```python
    async def process_message(self, session_id: str, message: str, stream: bool = False) -> Dict[str, Any]:
        """
        處理用戶消息 - 主要入口點
        回傳格式對齊 mgfd_ai.js 期望的結構
        """
        
    async def get_session_state(self, session_id: str) -> Dict[str, Any]:
        """獲取會話狀態 - 用於前端狀態顯示"""
        
    async def reset_session(self, session_id: str) -> Dict[str, Any]:
        """重置會話 - 清理狀態，重新開始"""
        
    async def get_system_status(self) -> Dict[str, Any]:
        """系統狀態 - 對齊 /api/mgfd_cursor/stats 端點"""
```

#### **1.3 核心流程設計（Think-Then-Act 架構）**
```python
    async def _process_message_internal(self, session_id: str, message: str) -> Dict[str, Any]:
        """
        內部消息處理流程
        1. 建立/讀取 context
        2. 解析用戶輸入
        3. 狀態機驅動
        4. 生成回應
        5. 更新狀態
        """
        
        # Step 1: 建立 context
        context = await self._build_context(session_id, message)
        
        # Step 2: 解析輸入（UserInputHandler）
        input_result = await self.user_input_handler.parse(message, context)
        context.update(input_result)
        
        # Step 3: 狀態機驅動（StateManager）
        state_result = await self.state_manager.process_state(context)
        context.update(state_result)
        
        # Step 4: 知識查詢（如需要）
        if context.get('needs_knowledge_search'):
            knowledge_result = await self.knowledge_manager.search(context)
            context.update(knowledge_result)
        
        # Step 5: 生成回應（ResponseGenerator）
        response_result = await self.response_generator.generate(context)
        context.update(response_result)
        
        # Step 6: 更新狀態
        await self.state_manager.update_session(session_id, context)
        
        return self._format_frontend_response(context)
```

### 二、UserInputHandler 進階設計（智能輸入解析）

#### **2.1 基於 default_slots.json 的槽位架構**
```python
class UserInputHandler:
    """
    用戶輸入處理器 - 智能解析自然語言為結構化數據
    基於 default_slots.json 的11個核心槽位
    """
    
    def __init__(self):
        self.slot_schema = {
            "用途": "usage_purpose",
            "價格區間": "price_range", 
            "推出時間": "release_time",
            "CPU效能": "cpu_performance",
            "GPU效能": "gpu_performance", 
            "重量": "weight",
            "攜帶性": "portability",
            "開關機速度": "boot_speed",
            "螢幕尺寸": "screen_size",
            "品牌": "brand",
            "觸控螢幕": "touch_screen"
        }
        
        # 意圖識別器
        self.intent_classifier = self._load_intent_classifier()
        
        # 槽位抽取器
        self.slot_extractor = self._load_slot_extractor()
```

#### **2.2 智能解析流程**
```python
    async def parse(self, message: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """
        解析用戶輸入
        回傳：意圖 + 槽位更新 + 控制指令
        """
        
        # Step 1: 意圖識別
        intent = await self._classify_intent(message, context)
        
        # Step 2: 槽位抽取
        slots_update = await self._extract_slots(message, context)
        
        # Step 3: 控制邏輯判斷
        control = await self._determine_control(intent, slots_update, context)
        
        # Step 4: 錯誤處理
        errors = await self._validate_input(message, intent, slots_update)
        
        return {
            "intent": intent,
            "slots_update": slots_update,
            "control": control,
            "errors": errors,
            "confidence": self._calculate_confidence(intent, slots_update)
        }
```

#### **2.3 意圖分類系統**
```python
    async def _classify_intent(self, message: str, context: Dict[str, Any]) -> str:
        """
        意圖分類 - 基於 recept_guest_prompt1.txt 的對話模式
        """
        intents = {
            "greet": ["你好", "您好", "hi", "hello"],
            "ask_recommendation": ["推薦", "建議", "找", "買", "要"],
            "ask_comparison": ["比較", "對比", "差異", "哪個好"],
            "provide_info": ["用來", "做", "玩", "工作", "學習"],
            "clarify": ["什麼意思", "不懂", "解釋"],
            "restart": ["重新開始", "重來", "reset"],
            "goodbye": ["再見", "謝謝", "bye"]
        }
        
        # 實現意圖匹配邏輯
        return self._match_intent(message, intents)
```

### 三、前端事件類型對齊（mgfd_ai.js 專用）

#### **3.1 回應格式設計**
```python
    def _format_frontend_response(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """
        格式化前端回應 - 對齊 mgfd_ai.js 期望格式
        """
        
        # 根據 context.stage 決定回應類型
        stage = context.get('stage', 'unknown')
        
        if stage == 'funnel_start':
            return {
                "type": "funnel_start",
                "message": context.get('funnel_intro', '歡迎使用筆電購物助手！'),
                "session_id": context.get('session_id')
            }
            
        elif stage == 'funnel_question':
            return {
                "type": "funnel_question", 
                "question": context.get('current_question'),
                "options": context.get('question_options', []),
                "session_id": context.get('session_id'),
                "message": context.get('question_message', '')
            }
            
        elif stage == 'recommendation':
            return {
                "type": "recommendation",
                "recommendations": context.get('recommendations', []),
                "comparison_table": context.get('comparison_table'),
                "summary": context.get('recommendation_summary'),
                "session_id": context.get('session_id')
            }
            
        elif stage == 'elicitation':
            return {
                "type": "elicitation",
                "message": context.get('elicitation_message'),
                "slots_needed": context.get('slots_needed', []),
                "session_id": context.get('session_id')
            }
            
        else:
            return {
                "type": "general",
                "message": context.get('response_message', ''),
                "session_id": context.get('session_id')
            }
```

#### **3.2 狀態機設計（對齊前端期望）**
```python
class StateManagementHandler:
    """
    狀態管理器 - 基於表驅動的狀態機
    """
    
    # 狀態定義（對齊 mgfd_ai.js 事件類型）
    STATES = {
        "INIT": "初始化",
        "FUNNEL_START": "漏斗開始", 
        "FUNNEL_QUESTION": "漏斗提問",
        "ELICITATION": "信息收集",
        "KNOWLEDGE_SEARCH": "知識查詢",
        "RECOMMENDATION": "推薦生成",
        "CLARIFICATION": "澄清確認",
        "COMPLETE": "完成"
    }
    
    # 狀態轉換表
    STATE_TRANSITIONS = {
        "INIT": StateTransition(
            actions=[self._initialize_session, self._determine_next_action],
            next_state="FUNNEL_START"
        ),
        "FUNNEL_START": StateTransition(
            actions=[self._build_funnel_intro],
            next_state="FUNNEL_QUESTION"
        ),
        "FUNNEL_QUESTION": StateTransition(
            actions=[self._process_user_answer, self._evaluate_slots],
            next_state="ELICITATION"  # 或 "KNOWLEDGE_SEARCH"
        ),
        # ... 更多狀態轉換
    }
```

### 四、槽位管理與漏斗設計

#### **4.1 基於 default_slots.json 的漏斗問題**
```python
    def _build_funnel_questions(self) -> List[Dict[str, Any]]:
        """
        基於 default_slots.json 構建漏斗問題
        對齊 recept_guest_prompt1.txt 的引導式問句
        """
        return [
            {
                "slot": "usage_purpose",
                "question": "請問您買這台電腦，最主要是用來做什麼呢？",
                "options": [
                    {"id": "work", "label": "工作辦公", "description": "文書處理、簡報製作"},
                    {"id": "study", "label": "學習上課", "description": "線上課程、作業完成"},
                    {"id": "gaming", "label": "遊戲娛樂", "description": "電競遊戲、影音娛樂"},
                    {"id": "creative", "label": "創意設計", "description": "影片剪輯、圖像設計"}
                ]
            },
            {
                "slot": "price_range", 
                "question": "方便請問一下您的預算大概是多少呢？",
                "options": [
                    {"id": "budget_low", "label": "2萬以下", "description": "經濟實惠"},
                    {"id": "budget_mid", "label": "2-4萬", "description": "性價比高"},
                    {"id": "budget_high", "label": "4-6萬", "description": "效能優異"},
                    {"id": "budget_premium", "label": "6萬以上", "description": "頂級配置"}
                ]
            },
            # ... 更多槽位問題
        ]
```

### 五、與 Prompt 管理整合

#### **5.1 Prompt 選擇策略**
```python
class PromptManagementHandler:
    """
    提示工程管理器 - 整合 MGFD_Principal_Prompt.txt 與 recept_guest_prompt1.txt
    """
    
    async def select_prompt(self, context: Dict[str, Any]) -> str:
        """
        根據對話階段選擇合適的提示
        """
        stage = context.get('stage')
        intent = context.get('intent')
        
        if stage == 'funnel_start':
            return self._get_funnel_intro_prompt()
        elif stage == 'elicitation':
            return self._get_elicitation_prompt(context)
        elif stage == 'recommendation':
            return self._get_recommendation_prompt(context)
        else:
            return self._get_general_prompt()
    
    def _get_funnel_intro_prompt(self) -> str:
        """基於 recept_guest_prompt1.txt 的開場提示"""
        return """
        身為一名專業且親切的筆記型電腦銷售專家，你的任務是主動迎接進入賣場的客戶，
        並引導他們完成一段愉快且有效率的購物體驗。
        
        你的對話應遵循以下結構與原則：
        1. 熱情開場與初步探索
        2. 引導式需求分析（核心任務）
        3. 確認需求與提出方案
        4. 處理疑慮與完成銷售
        """
```

### 六、實作檔案規劃

#### **6.1 檔案結構（libs/Implementation_references/claude/v2/）**
```
libs/Implementation_references/claude/v2/
├── MGFDKernel.py              # 核心控制器
├── UserInputHandler.py        # 輸入解析器
├── StateManagementHandler.py  # 狀態管理器
├── PromptManagementHandler.py # 提示管理器
├── ResponseGenHandler.py      # 回應生成器
├── KnowledgeManagementHandler.py # 知識管理器
├── actions/                   # 動作庫
│   ├── __init__.py
│   ├── funnel_actions.py     # 漏斗相關動作
│   ├── elicitation_actions.py # 信息收集動作
│   └── recommendation_actions.py # 推薦相關動作
├── models/                    # 數據模型
│   ├── __init__.py
│   ├── context.py            # 上下文模型
│   ├── slots.py              # 槽位模型
│   └── responses.py          # 回應模型
└── config/                   # 配置文件
    ├── __init__.py
    ├── slot_schema.py        # 槽位架構
    ├── state_transitions.py  # 狀態轉換表
    └── prompts.py            # 提示模板
```

這個設計確保了：
1. **完全對齊 mgfd_ai.js**：避免使用 sales_ai.js 相關邏輯
2. **基於 default_slots.json**：11個核心槽位的完整支援
3. **整合兩份提示文件**：企業級助理規範 + 引導式對話模式
4. **表驅動狀態機**：靈活可擴展的流程控制
5. **標準動作合約**：統一的 context 傳遞機制

你希望我開始實作哪個部分？